{
  "entries": [
    [
      "interceptors.md:71ef427115228fb97895b3a20fb6aff3",
      "### 拦截器\n\n拦截器是一种类，使用`装饰器`注解并实现`接口`。\n\n__HTML_TAG_86____HTML_TAG_87____HTML_TAG_88__\n\n拦截器拥有许多有用的功能，这些功能受到__LINK_91__ (AOP)技术的启发。它们使您可以：\n\n* 在方法执行前/后绑定额外的逻辑\n* 将函数返回的结果转换\n* 将函数抛出的异常转换\n* 扩展基本函数行为\n* 完全override函数，根据特定条件（例如，用于缓存目的）\n\n#### 基本概念\n\n每个拦截器都实现了`next()`方法，该方法接受两个参数。第一个参数是`ExecutionContext`实例（与__LINK_92__相同），而`AuthGuard`继承自`validateRequest()`。我们在异常过滤器章节中已经见过`canActivate()`。它是一个对arguments的"
    ],
    [
      "guards.md:552bdc023eef429c4c02b2a73b02436c",
      "###uard\n\nGuards 是一个类，使用 `app.controller.spec.ts` 装饰器注解，并实现 `app.module.ts` 接口。\n\n__HTML_TAG_68____HTML_TAG_69____HTML_TAG_70__\n\nGuards 只有一个责任：决定请求是否由路由处理程序处理，取决于某些在运行时存在的条件（如权限、角色、ACL 等）。这通常称为授权。授权（和其同伴身份验证）在传统的 Express 应用程序中通常由 [here](https://prettier.io/docs/en/comparison.html) 处理。Middleware 是身份验证的好选择，因为 things like token validation 和 attaching properties to the `app.service.ts` object 不是强烈相关于特定的路由上下文（及其 metadata）。\n\n但是，Middleware 自然是愚蠢的。它不知道将调用 `main.ts` 函数后执行的处理程序是什么。相反，Guards 有访问 `NestFactory` 实例的能力，因此知道将执行的下一个处理程序是什么。它们是设计来在请求/响应周期中的正确点插入处理"
    ],
    [
      "exception-filters.md:6e979218ab82a05d8c9d41fa362d4f82",
      "### Exception filters\n\nNest comes with a built-in **exceptions layer** which is responsible for processing all unhandled exceptions across an application. When an exception is not handled by your application code, it is caught by this layer, which then automatically sends an appropriate user-friendly response.\n\n<figure>\n  <img class=\"illustrative-image\" src=\"/assets/Filter_1.png\" />\n</figure>\n\nOut of the box, this action is performed by a built-in **global exception filter**, which handles exceptions of type `HttpException` (and subclasses of it). When an exception is **unrecognized** (is neither `HttpException` nor a class that inherits from `HttpException`), the built-in exception filter generates the following default JSON response:\n\n```json\n{\n  \"statusCode\": 500,\n  \"message\": \"Internal server error\"\n}\n```\n\n> info **Hint** The global exception filter partially supports the `http-errors` library. Basically, any thrown exception containing the `statusCode` and `message` properties will be properly populated and sent back as a response (instead of the default `InternalServerErrorException` for unrecognized exceptions).\n\n#### Throwing standard exceptions\n\nNest provides a built-in `HttpException` class, exposed from the `@nestjs/common` package. For typical HTTP REST/GraphQL API based applications, it's best practice to send standard HTTP response objects when certain error conditions occur.\n\nFor example, in the `CatsController`, we have a `findAll()` method (a `GET` route handler). Let's assume that this route handler throws an exception for some reason. To demonstrate this, we'll hard-code it as follows:\n\n```typescript\n@@filename(cats.controller)\n@Get()\nasync findAll() {\n  throw new HttpException('Forbidden', HttpStatus.FORBIDDEN);\n}\n```\n\n> info **Hint** We used the `HttpStatus` here. This is a helper enum imported from the `@nestjs/common` package.\n\nWhen the client calls this endpoint, the response looks like this:\n\n```json\n{\n  \"statusCode\": 403,\n  \"message\": \"Forbidden\"\n}\n```\n\nThe `HttpException` constructor takes two required arguments which determine the\nresponse:\n\n- The `response` argument defines the JSON response body. It can be a `string`\n  or an `object` as described below.\n- The `status` argument defines the [HTTP status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).\n\nBy default, the JSON response body contains two properties:\n\n- `statusCode`: defaults to the HTTP status code provided in the `status` argument\n- `message`: a short description of the HTTP error based on the `status`\n\nTo override just the message portion of the JSON response body, supply a string\nin the `response` argument. To override the entire JSON response body, pass an object in the `response` argument. Nest will serialize the object and return it as the JSON response body.\n\nThe second constructor argument - `status` - should be a valid HTTP status code.\nBest practice is to use the `HttpStatus` enum imported from `@nestjs/common`.\n\nThere is a **third** constructor argument (optional) - `options` - that can be used to provide an error [cause](https://nodejs.org/en/blog/release/v16.9.0/#error-cause). This `cause` object is not serialized into the response object, but it can be useful for logging purposes, providing valuable information about the inner error that caused the `HttpException` to be thrown.\n\nHere's an example overriding the entire response body and providing an error cause:\n\n```typescript\n@@filename(cats.controller)\n@Get()\nasync findAll() {\n  try {\n    await this.service.findAll()\n  } catch (error) {\n    throw new HttpException({\n      status: HttpStatus.FORBIDDEN,\n      error: 'This is a custom message',\n    }, HttpStatus.FORBIDDEN, {\n      cause: error\n    });\n  }\n}\n```\n\nUsing the above, this is how the response would look:\n\n```json\n{\n  \"status\": 403,\n  \"error\": \"This is a custom message\"\n}\n```\n\n#### Exceptions logging\n\nBy default, the exception filter does not log built-in exceptions like `HttpException` (and any exceptions that inherit from it). When these exceptions are thrown, they won't appear in the console, as they are treated as part of the normal application flow. The same behavior applies to other built-in exceptions such as `WsException` and `RpcException`.\n\nThese exceptions all inherit from the base `IntrinsicException` class, which is exported from the `@nestjs/common` package. This class helps differentiate between exceptions that are part of normal application operation and those that are not.\n\nIf you want to log these exceptions, you can create a custom exception filter. We'll explain how to do this in the next section.\n\n#### Custom exceptions\n\nIn many cases, you will not need to write custom exceptions, and can use the built-in Nest HTTP exception, as described in the next section. If you do need to create customized exceptions, it's good practice to create your own **exceptions hierarchy**, where your custom exceptions inherit from the base `HttpException` class. With this approach, Nest will recognize your exceptions, and automatically take care of the error responses. Let's implement such a custom exception:\n\n```typescript\n@@filename(forbidden.exception)\nexport class ForbiddenException extends HttpException {\n  constructor() {\n    super('Forbidden', HttpStatus.FORBIDDEN);\n  }\n}\n```\n\nSince `ForbiddenException` extends the base `HttpException`, it will work seamlessly with the built-in exception handler, and therefore we can use it inside the `findAll()` method.\n\n```typescript\n@@filename(cats.controller)\n@Get()\nasync findAll() {\n  throw new ForbiddenException();\n}\n```\n\n#### Built-in HTTP exceptions\n\nNest provides a set of standard exceptions that inherit from the base `HttpException`. These are exposed from the `@nestjs/common` package, and represent many of the most common HTTP exceptions:\n\n- `BadRequestException`\n- `UnauthorizedException`\n- `NotFoundException`\n- `ForbiddenException`\n- `NotAcceptableException`\n- `RequestTimeoutException`\n- `ConflictException`\n- `GoneException`\n- `HttpVersionNotSupportedException`\n- `PayloadTooLargeException`\n- `UnsupportedMediaTypeException`\n- `UnprocessableEntityException`\n- `InternalServerErrorException`\n- `NotImplementedException`\n- `ImATeapotException`\n- `MethodNotAllowedException`\n- `BadGatewayException`\n- `ServiceUnavailableException`\n- `GatewayTimeoutException`\n- `PreconditionFailedException`\n\nAll the built-in exceptions can also provide both an error `cause` and an error description using the `options` parameter:\n\n```typescript\nthrow new BadRequestException('Something bad happened', {\n  cause: new Error(),\n  description: 'Some error description',\n});\n```\n\nUsing the above, this is how the response would look:\n\n```json\n{\n  \"message\": \"Something bad happened\",\n  \"error\": \"Some error description\",\n  \"statusCode\": 400\n}\n```\n\n#### Exception filters\n\nWhile the base (built-in) exception filter can automatically handle many cases for you, you may want **full control** over the exceptions layer. For example, you may want to add logging or use a different JSON schema based on some dynamic factors. **Exception filters** are designed for exactly this purpose. They let you control the exact flow of control and the content of the response sent back to the client.\n\nLet's create an exception filter that is responsible for catching exceptions which are an instance of the `HttpException` class, and implementing custom response logic for them. To do this, we'll need to access the underlying platform `Request` and `Response` objects. We'll access the `Request` object so we can pull out the original `url` and include that in the logging information. We'll use the `Response` object to take direct control of the response that is sent, using the `response.json()` method.\n\n```typescript\n@@filename(http-exception.filter)\nimport { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';\nimport { Request, Response } from 'express';\n\n@Catch(HttpException)\nexport class HttpExceptionFilter implements ExceptionFilter {\n  catch(exception: HttpException, host: ArgumentsHost) {\n    const ctx = host.switchToHttp();\n    const response = ctx.getResponse<Response>();\n    const request = ctx.getRequest<Request>();\n    const status = exception.getStatus();\n\n    response\n      .status(status)\n      .json({\n        statusCode: status,\n        timestamp: new Date().toISOString(),\n        path: request.url,\n      });\n  }\n}\n@@switch\nimport { Catch, HttpException } from '@nestjs/common';\n\n@Catch(HttpException)\nexport class HttpExceptionFilter {\n  catch(exception, host) {\n    const ctx = host.switchToHttp();\n    const response = ctx.getResponse();\n    const request = ctx.getRequest();\n    const status = exception.getStatus();\n\n    response\n      .status(status)\n      .json({\n        statusCode: status,\n        timestamp: new Date().toISOString(),\n        path: request.url,\n      });\n  }\n}\n```\n\n> info **Hint** All exception filters should implement the generic `ExceptionFilter<T>` interface. This requires you to provide the `catch(exception: T, host: ArgumentsHost)` method with its indicated signature. `T` indicates the type of the exception.\n\n> warning **Warning** If you are using `@nestjs/platform-fastify` you can use `response.send()` instead of `response.json()`. Don't forget to import the correct types from `fastify`.\n\nThe `@Catch(HttpException)` decorator binds the required metadata to the exception filter, telling Nest that this particular filter is looking for exceptions of type `HttpException` and nothing else. The `@Catch()` decorator may take a single parameter, or a comma-separated list. This lets you set up the filter for several types of exceptions at once.\n\n#### Arguments host\n\nLet's look at the parameters of the `catch()` method. The `exception` parameter is the exception object currently being processed. The `host` parameter is an `ArgumentsHost` object. `ArgumentsHost` is a powerful utility object that we'll examine further in the [execution context chapter](/fundamentals/execution-context)\\*. In this code sample, we use it to obtain a reference to the `Request` and `Response` objects that are being passed to the original request handler (in the controller where the exception originates). In this code sample, we've used some helper methods on `ArgumentsHost` to get the desired `Request` and `Response` objects. Learn more about `ArgumentsHost` [here](/fundamentals/execution-context).\n\n\\*The reason for this level of abstraction is that `ArgumentsHost` functions in all contexts (e.g., the HTTP server context we're working with now, but also Microservices and WebSockets). In the execution context chapter we'll see how we can access the appropriate <a href=\"https://docs.nestjs.com/fundamentals/execution-context#host-methods\">underlying arguments</a> for **any** execution context with the power of `ArgumentsHost` and its helper functions. This will allow us to write generic exception filters that operate across all contexts.\n\n<app-banner-courses></app-banner-courses>\n\n#### Binding filters\n\nLet's tie our new `HttpExceptionFilter` to the `CatsController`'s `create()` method.\n\n```typescript\n@@filename(cats.controller)\n@Post()\n@UseFilters(new HttpExceptionFilter())\nasync create(@Body() createCatDto: CreateCatDto) {\n  throw new ForbiddenException();\n}\n@@switch\n@Post()\n@UseFilters(new HttpExceptionFilter())\n@Bind(Body())\nasync create(createCatDto) {\n  throw new ForbiddenException();\n}\n```\n\n> info **Hint** The `@UseFilters()` decorator is imported from the `@nestjs/common` package.\n\nWe have used the `@UseFilters()` decorator here. Similar to the `@Catch()` decorator, it can take a single filter instance, or a comma-separated list of filter instances. Here, we created the instance of `HttpExceptionFilter` in place. Alternatively, you may pass the class (instead of an instance), leaving responsibility for instantiation to the framework, and enabling **dependency injection**.\n\n```typescript\n@@filename(cats.controller)\n@Post()\n@UseFilters(HttpExceptionFilter)\nasync create(@Body() createCatDto: CreateCatDto) {\n  throw new ForbiddenException();\n}\n@@switch\n@Post()\n@UseFilters(HttpExceptionFilter)\n@Bind(Body())\nasync create(createCatDto) {\n  throw new ForbiddenException();\n}\n```\n\n> info **Hint** Prefer applying filters by using classes instead of instances when possible. It reduces **memory usage** since Nest can easily reuse instances of the same class across your entire module.\n\nIn the example above, the `HttpExceptionFilter` is applied only to the single `create()` route handler, making it method-scoped. Exception filters can be scoped at different levels: method-scoped of the controller/resolver/gateway, controller-scoped, or global-scoped.\nFor example, to set up a filter as controller-scoped, you would do the following:\n\n```typescript\n@@filename(cats.controller)\n@Controller()\n@UseFilters(new HttpExceptionFilter())\nexport class CatsController {}\n```\n\nThis construction sets up the `HttpExceptionFilter` for every route handler defined inside the `CatsController`.\n\nTo create a global-scoped filter, you would do the following:\n\n```typescript\n@@filename(main)\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  app.useGlobalFilters(new HttpExceptionFilter());\n  await app.listen(process.env.PORT ?? 3000);\n}\nbootstrap();\n```\n\n> warning **Warning** The `useGlobalFilters()` method does not set up filters for gateways or hybrid applications.\n\nGlobal-scoped filters are used across the whole application, for every controller and every route handler. In terms of dependency injection, global filters registered from outside of any module (with `useGlobalFilters()` as in the example above) cannot inject dependencies since this is done outside the context of any module. In order to solve this issue, you can register a global-scoped filter **directly from any module** using the following construction:\n\n```typescript\n@@filename(app.module)\nimport { Module } from '@nestjs/common';\nimport { APP_FILTER } from '@nestjs/core';\n\n@Module({\n  providers: [\n    {\n      provide: APP_FILTER,\n      useClass: HttpExceptionFilter,\n    },\n  ],\n})\nexport class AppModule {}\n```\n\n> info **Hint** When using this approach to perform dependency injection for the filter, note that regardless of the module where this construction is employed, the filter is, in fact, global. Where should this be done? Choose the module where the filter (`HttpExceptionFilter` in the example above) is defined. Also, `useClass` is not the only way of dealing with custom provider registration. Learn more [here](/fundamentals/custom-providers).\n\nYou can add as many filters with this technique as needed; simply add each to the providers array.\n\n#### Catch everything\n\nIn order to catch **every** unhandled exception (regardless of the exception type), leave the `@Catch()` decorator's parameter list empty, e.g., `@Catch()`.\n\nIn the example below we have a code that is platform-agnostic because it uses the [HTTP adapter](./faq/http-adapter) to deliver the response, and doesn't use any of the platform-specific objects (`Request` and `Response`) directly:\n\n```typescript\nimport {\n  ExceptionFilter,\n  Catch,\n  ArgumentsHost,\n  HttpException,\n  HttpStatus,\n} from '@nestjs/common';\nimport { HttpAdapterHost } from '@nestjs/core';\n\n@Catch()\nexport class CatchEverythingFilter implements ExceptionFilter {\n  constructor(private readonly httpAdapterHost: HttpAdapterHost) {}\n\n  catch(exception: unknown, host: ArgumentsHost): void {\n    // In certain situations `httpAdapter` might not be available in the\n    // constructor method, thus we should resolve it here.\n    const { httpAdapter } = this.httpAdapterHost;\n\n    const ctx = host.switchToHttp();\n\n    const httpStatus =\n      exception instanceof HttpException\n        ? exception.getStatus()\n        : HttpStatus.INTERNAL_SERVER_ERROR;\n\n    const responseBody = {\n      statusCode: httpStatus,\n      timestamp: new Date().toISOString(),\n      path: httpAdapter.getRequestUrl(ctx.getRequest()),\n    };\n\n    httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus);\n  }\n}\n```\n\n> warning **Warning** When combining an exception filter that catches everything with a filter that is bound to a specific type, the \"Catch anything\" filter should be declared first to allow the specific filter to correctly handle the bound type.\n\n#### Inheritance\n\nTypically, you'll create fully customized exception filters crafted to fulfill your application requirements. However, there might be use-cases when you would like to simply extend the built-in default **global exception filter**, and override the behavior based on certain factors.\n\nIn order to delegate exception processing to the base filter, you need to extend `BaseExceptionFilter` and call the inherited `catch()` method.\n\n```typescript\n@@filename(all-exceptions.filter)\nimport { Catch, ArgumentsHost } from '@nestjs/common';\nimport { BaseExceptionFilter } from '@nestjs/core';\n\n@Catch()\nexport class AllExceptionsFilter extends BaseExceptionFilter {\n  catch(exception: unknown, host: ArgumentsHost) {\n    super.catch(exception, host);\n  }\n}\n@@switch\nimport { Catch } from '@nestjs/common';\nimport { BaseExceptionFilter } from '@nestjs/core';\n\n@Catch()\nexport class AllExceptionsFilter extends BaseExceptionFilter {\n  catch(exception, host) {\n    super.catch(exception, host);\n  }\n}\n```\n\n> warning **Warning** Method-scoped and Controller-scoped filters that extend the `BaseExceptionFilter` should not be instantiated with `new`. Instead, let the framework instantiate them automatically.\n\nGlobal filters **can** extend the base filter. This can be done in either of two ways.\n\nThe first method is to inject the `HttpAdapter` reference when instantiating the custom global filter:\n\n```typescript\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n\n  const { httpAdapter } = app.get(HttpAdapterHost);\n  app.useGlobalFilters(new AllExceptionsFilter(httpAdapter));\n\n  await app.listen(process.env.PORT ?? 3000);\n}\nbootstrap();\n```\n\nThe second method is to use the `APP_FILTER` token <a href=\"exception-filters#binding-filters\">as shown here</a>.\n"
    ],
    [
      "support.md:ebae2054b66b14d7be81cb940de1a50e",
      "### 支持\n\nNest 是一项 MIT 许可证的开源项目，它的持续发展是由社区的支持所可能的。该框架是长期努力的结果，包括无数的没有睡眠的夜晚、工作**晚上的时间**和忙碌的周末。\n\n#### 如何帮助？\n\nNest 没有一个大公司后台，持续付款开发的时间。我完全依靠人们的**善意** ❤️。然而，我想使该框架变得更加**强大**，完全专注于为您提供出色的解决方案，使编码过程更加愉悦：为了帮助我，我运行了几个支持平台：\n\n- 成为背后的支持者或赞助人：__LINK_0__\n- 使用__LINK_1__发送一次捐款\n- 或直接联系我：__LINK_2__\n\n如果您对 Nest 感情深深，或者您运营的业务使用 Nest，考虑赞助其发展，以确保项目，您的产品依赖的项目是**积极维护**和改进的。同时，您的支持也可能帮助我更多地工作于为 Nest 社区整体提供的内容，编写教育性博客文章或录制视频。"
    ],
    [
      "modules.md:f0a3b46ccd20fd1f6cabdf7b5f50cf8b",
      "### 模块\n\n模块是一种在 `data` 装饰器下注解的类。这个装饰器提供了元数据，Nest 使用它来组织和管理应用程序结构的效率。\n\n<td><code></code>\n\n每个 Nest 应用程序至少有一个模块，即 **根模块**，它作为 Nest 构建应用程序图结构的起点。这幅图是一个内部结构，Nest 使用它来解决模块和提供者的关系和依赖关系。在小型应用程序中可能只有一个根模块，但这通常不是情况。模块是 **强烈推荐** 的一种组织组件的方法。对于大多数应用程序，您将拥有多个模块，每个模块 encapsulates 一组紧密相关的 **能力**。\n\n`user` 装饰器接受一个包含模块描述的单个对象：\n\n|               |                                                                                                                                                                                                          |\n| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `@User()`   | 模块中将被 Nest 注册的提供者，可能在至少这个模块中共享的 |\n| `user` | 在这个模块中定义的控制器列表，需要被实例化 |\n| `createParamDecorator<T>()`     | 导入的模块列表，该模块导出在这个模块中需要的提供者 |\n| `createParamDecorator<string>((data, ctx) => ...)`     | 在这个模块中提供"
    ],
    [
      "middlewares.md:cd146da5cc51149df7fee77d2682c4fe",
      "### Middleware\n\nMiddleware 是一种函数，**在**路由处理器之前被调用。Middleware 函数可以访问 __LINK_93__ 和 __LINK_94__ 对象，以及应用程序的请求-响应周期中的 `$ nest g service cats` 中间件函数。中间件函数的 **next** 函数通常被 denoted 为一个名为 `CatsService` 的变量。\n\n__HTML_TAG_72____HTML_TAG_73____HTML_TAG_74__\n\nNest 中间件默认情况下是等同于 __LINK_95__ 中间件的。以下是官方 Express 文档中对中间件的描述：\n\n__HTML_TAG_75__\n  中间件函数可以执行以下任务：\n  __HTML_TAG_76__\n    __HTML_TAG_77__执行任何代码。\n    __HTML_TAG_79__更改请求和响应对象。\n    __HTML_TAG_81__结束请求-响应周期。\n    __HTML_TAG_83__调用中间件函数栈中的下一个函数。\n    __HTML_TAG_85__如果当前中间件函数不结束请求-响应周期，它必须调用 __HTML_TAG_86__next()__HTML_TAG_87__以将控制权传递给下一个中间件函数。否则，请求将被留下。\n  __HTML_TAG_89__\n__HTML_TAG_90__\n\n您可以在函数或带有 `@Injectable()` 装饰器的类中实现自定义 Nest 中间件。类应该实现 `CatsService` 接口，而函数没有特殊要求。让我们从实现一个简单的中间件功能开始，使用类方法。\n\n> warning **Warning** `Cat` 和 `CatsController` 处理中间件 differently 和提供不同的方法签名，阅读更多 __LINK_96__。\n\n```typescript\n@@filename(cats.service)\nimport { Injectable } from '@nestjs/common';\nimport { Cat } from './interfaces/cat.interface';\n\n@Injectable()\nexport class CatsService {\n  private readonly cats: Cat[] = [];\n\n  create(cat: Cat) {\n    this.cats.push(cat);\n  }\n\n  findAll(): Cat[] {\n    return this.cats;\n  }\n}\n@@switch\nimport { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class CatsService {\n  constructor() {\n    this.cats = [];\n  }\n\n  create(cat) {\n    this.cats.push(cat);\n  }\n\n  findAll() {\n    return this.cats;\n  }\n}\n```\n\n#### 依赖注入\n\nNest 中间件完全支持依赖注入。正如对提供者和控制器一样，他们可以**注入依赖项**，这些依赖项在同一个模块中可用。正如通常一样，这是通过 `CatsService` 进行的。\n\n#### 应用中间件\n\n中间件没有在 `private` 装饰器中。相反，我们使用 `catsService` 模块类的方法来设置它们。包含中间件的模块必须实现 `catsService` 接口。让我们在 `@Optional()` 水平上设置 `HTTP_OPTIONS`。\n\n```typescript\n@@filename(interfaces/cat.interface)\nexport interface Cat {\n  name: string;\n  age: number;\n  breed: string;\n}\n```\n\n在上面的示例中，我们已经设置了 `HTTP_OPTIONS` 对于之前在 `@Inject()` 中定义的 `super()` 路由处理器。我们也可以进一步限制中间件到特定的请求方法，通过在配置中间件时传递包含路由 `@Inject` 和请求 `CatsService` 的对象。例如，在下面的示例中，我们导入了 `app.module.ts` 枚举以引用所需的请求方法类型。\n\n```typescript\n@@filename(cats.controller)\nimport { Controller, Get, Post, Body } from '@nestjs/common';\nimport { CreateCatDto } from './dto/create-cat.dto';\nimport { CatsService } from './cats.service';\nimport { Cat } from './interfaces/cat.interface';\n\n@Controller('cats')\nexport class CatsController {\n  constructor(private catsService: CatsService) {}\n\n  @Post()\n  async create(@Body() createCatDto: CreateCatDto) {\n    this.catsService.create(createCatDto);\n  }\n\n  @Get()\n  async findAll(): Promise<Cat[]> {\n    return this.catsService.findAll();\n  }\n}\n@@switch\nimport { Controller, Get, Post, Body, Bind, Dependencies } from '@nestjs/common';\nimport { CatsService } from './cats.service';\n\n@Controller('cats')\n@Dependencies(CatsService)\nexport class CatsController {\n  constructor(catsService) {\n    this.catsService = catsService;\n  }\n\n  @Post()\n  @Bind(Body())\n  async create(createCatDto) {\n    this.catsService.create(createCatDto);\n  }\n\n  @Get()\n  async findAll() {\n    return this.catsService.findAll();\n  }\n}\n```\n\n> info **Hint** `providers` 方法可以使用 `@Module()` 进行异步操作（例如，在 `bootstrap()` 方法体中完成异步操作）。\n\n> warning **Warning** 使用 __INLINE_CODE_34__ 适配器"
    ],
    [
      "enterprise.md:ff943a72765d42d17ae6436a9115a90a",
      "### 官方NestJS咨询\n\n我们的目标是确保您的开发者在使用NestJS和其他现代技术时成功和高效。\n\n### 官方支持\n\n通过官方支持，您可以直接从NestJS核心团队获取专家的帮助。我们将解决您最困难的问题，并与您的团队在多个层面上合作，例如：\n\n- 提供技术指南和架构 review\n- **指导**团队成员\n- 提供建议\n- 解决设计决策\n- 处理安全和性能问题\n- 进行深入的代码 review\n\n__HTML_TAG_0__\n  __HTML_TAG_1__\n    __HTML_TAG_2__团队增强与开发__HTML_TAG_3__\n    __HTML_TAG_4__\n      通过团队增强，NestJS核心团队成员可以与您的团队在日常基础上合作，以帮助您的项目达到新的高度。考虑我们“您的团队的一部分”，与您一起解决最复杂的项目。\n    __HTML_TAG_5__\n  __HTML_TAG_6__\n  __HTML_TAG_7__\n    __HTML_TAG_8__\n  __HTML_TAG_9__\n__HTML_TAG_10__\n\n__HTML_TAG_11__\n__HTML_TAG_12__\n    __HTML_TAG_13__\n  __HTML_TAG_14__\n  __HTML_TAG_15__\n    __HTML_TAG_16__NestJS最佳实践<table>\n    <tr>\n      频繁的代码 review 可以在早期消除潜在的 bugs 和问题，并帮助实施最佳实践。让我们执行 PR 检查和审核，以确保您的代码质量、性能和安全。\n    <td>\n  <code>\n</code>\n\n####第一手访问\n\n直接通信渠道将加速团队速度，为您提供快速访问讨论和解决问题。\n\n####NestJS工作坊和培训\n\n我们提供solid的启动培训，以及更advanced的一些，以帮助团队深入理解NestJS。我们提供在现场的工作坊和远程的集中会话，以帮助您在NestJS生态系统中快速上手。\n\n</td>\n  <td>\n    </td>联系我们！</tr>\n    <tr>\n    让我们谈论如何帮助您成功使用NestJS。\n    <td> \n  <code>\n   </code>\n     </td>联系我们<td>\n   </td>\n</tr>\n\n请与我们联系到 __LINK_34__，让我们讨论您的项目和团队需求！"
    ],
    [
      "custom-decorators.md:1612f80cc9137a7e0ce43c033b90361f",
      "### 自定义路由装饰器\n\nNest 是基于 JavaScript 语言特性称为 **装饰器** 的语言特性。装饰器在许多常用的编程语言中是非常知名的，但是在 JavaScript 世界中仍然是相对较新的概念。在更好地理解装饰器工作之前，我们推荐阅读 __LINK_147__。下面是一个简单的定义：\n\n</code>\n  ES2016 装饰器是一个返回函数的表达式，可以带有目标、名称和属性描述符三个参数。你可以通过在要装饰的内容前加上 </td>@<td> 字符并将其置于顶部来应用装饰器。装饰器可以定义为类、方法或属性。\n\n#### Param 装饰器\n\nNest 提供了一些有用的 **param 装饰器**，可以与 HTTP 路由处理程序一起使用。下面是一个装饰器列表和它们所对应的 plain Express (或 Fastify) 对象\n\n</tr>\n  </table>\n    __HTML_TAG_35__\n      __HTML_TAG_36____HTML_TAG_37__@Request(), @Req()__HTML_TAG_38____HTML_TAG_39__\n      __HTML_TAG_40____HTML_TAG_41__req__HTML_TAG_42____HTML_TAG_43__\n    __HTML_TAG_44__\n    __HTML_TAG_45__\n      __HTML_TAG_46____HTML_TAG_47__@Response(), @Res()__HTML_TAG_48____HTML_TAG_49__\n      __HTML_TAG_50____HTML_TAG_51__res__HTML_TAG_52____HTML_TAG_53__\n    __HTML_TAG_54__\n    __HTML_TAG_55__\n      __HTML_TAG_56____HTML_TAG_57__@Next()__HTML_TAG_58____HTML_TAG_59__\n      __HTML_TAG_60____HTML_TAG_61__next__HTML_TAG_62____HTML_TAG_63__\n    __HTML_TAG_64__\n    __HTML_TAG_65__\n      __HTML_TAG_66____HTML_TAG_67__@Session()__HTML_TAG_68____HTML_TAG_69__\n      __HTML_TAG_70____HTML_TAG_71__req.session__HTML_TAG_72____HTML_TAG_73__\n    __HTML_TAG_74__\n    __HTML_TAG_75__\n      __HTML_TAG_76____HTML_TAG_77__@Param(param?: string)__HTML_TAG_78____HTML_TAG_79__\n      __HTML_TAG_80____HTML_TAG_81__req.params__HTML_TAG_82__ / __HTML_TAG_83__req.params[param]__HTML_TAG_84____HTML_TAG_85__\n    __HTML_TAG_86__\n    __HTML_TAG_87__\n      __HTML_TAG_88____HTML_TAG_89__@Body(param?: string)__HTML_TAG_90____HTML_TAG_91__\n      __HTML_TAG_92____HTML_TAG_93__req.body__HTML_TAG_94__ / __HTML_TAG_95__req.body[param]__HTML_TAG_96____HTML_TAG_97__\n    __HTML_TAG_98__\n    __HTML_TAG_99__\n      __HTML_TAG_100____HTML_TAG_101__@Query(param?: string)__HTML_TAG_102____HTML_TAG_103__\n      __HTML_TAG_104____HTML_TAG_105__req.query__HTML_TAG_106__ /"
    ],
    [
      "first-steps.md:85c8b00be3eb10d6c18cce99278fa429",
      "### 第一个步骤\n\n在这个系列中，我们将学习Nest的**核心基础知识**。为了amiliarize ourselves with the essential building blocks of Nest应用程序，我们将创建一个基本的 CRUD 应用程序，该应用程序具有介绍性级别的特性。\n\n#### 语言\n\n我们对 __LINK_59__ 深深地迷恋，但最重要的是 —— 我们爱 __LINK_60__。因此，Nest 兼容 TypeScript 和纯 JavaScript。Nest 利用了最新的语言特性，因此要使用它与纯 JavaScript，我们需要一个 __LINK_61__ 编译器。\n\n我们大多数使用 TypeScript 在示例中，但是您总是可以**切换代码快照**到纯 JavaScript 语法（简单地单击上右手角的语言按钮）。\n\n#### 前提\n\n请确保 __LINK_62__ (版本 >= 20) 在您的操作系统中安装。\n\n#### 设置\n\n设置一个新的项目非常简单使用 __LINK_63__。使用 __LINK_64__ 安装后，您可以使用以下命令在您的 OS 终端中创建一个新的 Nest 项目：\n\n```typescript\n@@filename()\nasync function bootstrap() {\n  const app = await NestFactory.createApplicationContext(AppModule);\n  // your application logic here ...\n}\nbootstrap();\n```\n\n> info **提示**要创建一个使用 TypeScript 的 __LINK_65__  feature set 的新项目，请将 `TasksService` 标志传递给 `TasksModule` 命令。\n\n`AppModule` 目录将被创建，node 模块和一些其他基本文件将被安装，并且 `TasksService` 目录将被创建并填充几个核心文件。\n\n__HTML_TAG_41__\n  __HTML_TAG_42__src__HTML_TAG_43__\n  __HTML_TAG_44__\n    __HTML_TAG_45__app.controller.spec.ts__HTML_TAG_46__\n    __HTML_TAG_47__app.controller.ts__HTML_TAG_48__\n    __HTML_TAG_49__app.module.ts__HTML_TAG_50__\n    __HTML_TAG_51__app.service.ts__HTML_TAG_52__\n    __HTML_TAG_53__main.ts__HTML_TAG_54__\n  __HTML_TAG_55__\n__HTML_TAG_56__\n\n这些核心文件的简要概述如下：\n\n|                          |                                                                                                                     |\n| ------------------------ | ------------------------------------------------------------------------------------------------------------------- |\n| `get()`      | 一个基本的控制器具有一个单个路由。                                                                             |\n| `get()` | 控制器的单元测试。                                                                                  |\n| `strict: true`          | 应用程序的根模块。                                                                                 |\n| `app.get()`         | 一个基本的服务具有一个单个方法。                                                                               |\n| `app.select`                | 应用程序的入口文件，使用核心函数 `app.close()` 创建一个 Nest 应用程序实例。 |\n\n`bootstrap` 包含一个异步函数，它将**引导**我们的应用程序：\n\n```typescript\n@@filename()\nconst tasksService = app.get(TasksService);\n```\n\n创建一个 Nest 应用程序实例，我们使用核心 __INLINE_CODE_17__ 类。 __INLINE_CODE_18__ expose 一个静态方法，该方法允许创建一个应用程序实例。 __INLINE_CODE_19__ 方法返回一个应用程序对象，该对象实现了 __INLINE_CODE_20__ 接口。这个对象提供了一些方法，这些方法将在后续章节中描述。在 __INLINE_CODE_21__ 示例中，我们简单地启动我们的 HTTP 侦听器，让应用程序等待 inbound HTTP 请求。\n\n请注意，使用 Nest CLI 生成的项目创建了一个初始项目结构，鼓励开发者遵循将每个模块保持在其自己的专门目录中的约定。\n\n> info **提示**如果在创建应用程序时发生任何错误，应用程序将退出并返回代码 __INLINE_CODE_22__。如果您想要使它抛出错误而不是退出， disable 选项 __INLINE_CODE_23__ (例如 __INLINE_CODE_24__）。\n\n__HTML_TAG_57____HTML_TAG_58__\n\n#### 平台\n\nNest 的目标是成为一个平台无关的框架。平台独立使得我们可以创建可在多种类型的应用程序"
    ],
    [
      "components.md:6ce6fbe3fbb9feed1d3f56c8fcb34385",
      "### 提供者\n\n提供者是 Nest 的核心概念。许多基本的 Nest 类，例如服务、存储库、工厂和帮助类，可以被视为提供者。提供者的关键思想是，它可以作为依赖项被注入，允许对象之间形成各种关系。 Nest 运行时系统主要负责“连接”这些对象。\n\n</table>__HTML_TAG_35____HTML_TAG_36__\n\n在前一章中，我们创建了一个简单的 `TasksModule`. 控制器应该处理 HTTP 请求，并将更复杂的任务委托给 **提供者**。提供者是plain JavaScript 类，声明在 NestJS 模块中，以 `AppModule` 的形式。有关详细信息，请参阅“模块”章节。\n\n> info **提示**由于 Nest 允许您按照对象模型设计和组织依赖项，我们强烈建议遵循 __LINK_69__。\n\n#### 服务\n\n让我们创建一个简单的 `TasksService`. 这个服务将负责数据存储和检索，并将被 `get()` 使用。由于其在应用程序逻辑管理中的角色，它是一个理想的候选人，以被定义为提供者。\n\n```typescript\n@@filename()\nasync function bootstrap() {\n  const app = await NestFactory.createApplicationContext(AppModule);\n  // your application logic here ...\n}\nbootstrap();\n```\n\n> info **提示**使用 CLI 创建服务，仅需执行 `get()` 命令。\n\n我们的 `strict: true` 是一个基本类，具有一个属性和两个方法。关键添加的是 `app.get()` 装饰器。这装饰器将 metadata 附加到类中，表明 `app.select` 是可以由 Nest __LINK_70__ 容器管理的类。\n\n此外，这个示例还使用了 `app.close()` 接口，这可能看起来像这样：\n\n```typescript\n@@filename()\nconst tasksService = app.get(TasksService);\n```\n\n现在，我们已经有了一个服务类来检索猫，让我们在 `bootstrap` 中使用它：\n\n```typescript\n@@filename()\nconst tasksService = app.select(TasksModule).get(TasksService, { strict: true });\n```\n\n__INLINE_CODE_17__ 是通过类构造函数注入的。注意使用 __INLINE_CODE_18__ 关键字。这便捷方式允许我们同时声明和初始化 __INLINE_CODE_19__ 成员，简化了过程。\n\n#### 依赖项注入\n\nNest 是基于强大的设计模式的，即 **依赖项注入**。我们强烈建议阅读官方 __LINK_71__ 关于这个概念的文章。\n\n在 Nest 中， thanks to TypeScript 的能力，管理依赖项是非常简单的，因为它们是根据类型 resolves 的。在下面的示例中，Nest 将 resolve __INLINE_CODE_20__，创建并返回一个 __INLINE_CODE_21__ 实例（或，在单例模式下，如果已经请求过其他地方，将返回现有实例）。这个依赖项然后被注入到控制器的构造函数中（或分配到指定的属性）：\n\n```typescript\n@@filename()\nexport const dynamicConfigModule = ConfigModule.register({ folder: './config' });\n\n@Module({\n  imports: [dynamicConfigModule],\n})\nexport class AppModule {}\n```\n\n#### 作用域\n\n提供者通常具有与应用程序生命周期相Align 的生命周期（“作用域”）。当应用程序启动时，每个依赖项都必须被解决，meaning every provider gets instantiated。同样，当应用程序关闭时，所有提供者都将被销毁。然而，也可以使提供者 **请求作用域**，即其生命周期与特定请求相关。您可以在 __LINK_72__ 章节中了解这些技术。\n\n__HTML_TAG_37____HTML_TAG_38__\n\n#### 自定义提供者\n\nNest 带有内置的反向控制（“IoC”）容器，管理提供者之间的关系。这特性是依赖项注入的基础，但实际上是非常强大得多。有多种方式定义提供者：您"
    ],
    [
      "application-context.md:bf353bde471172137e68e802219e3e46",
      "### standalone 应用\n\nNest 应用程序可以有多种方式进行挂载。您可以创建一个 web 应用程序、一个微服务或只是一个没有网络监听器的 Nest standalone 应用程序（无网络监听器）。Nest standalone 应用程序是一个对 Nest IoC 容器的包装器，它持有所有实例化的类。我们可以从任何导入的模块中使用 standalone 应用程序对象来获取任何已存在的实例的引用。因此，您可以在任何地方使用 Nest 框架，包括例如脚本的 CRON 工作或 CLI。\n\n#### 入门\n\n创建一个 Nest standalone 应用程序请使用以下构造：\n\n```typescript\n@@filename()\nasync function bootstrap() {\n  const app = await NestFactory.createApplicationContext(AppModule);\n  // your application logic here ...\n}\nbootstrap();\n```\n\n#### 从静态模块中获取提供者\n\nstandalone 应用程序对象允许您获取 Nest 应用程序中注册的任何实例的引用。让我们假设我们在 `TasksService` 模块中有一个 `TasksModule` 提供者，该模块被我们的 `AppModule` 模块导入。这类提供者提供了一组方法，我们想从 CRON 工作中调用这些方法。\n\n```typescript\n@@filename()\nconst tasksService = app.get(TasksService);\n```\n\n要访问 `TasksService` 实例，我们使用 `get()` 方法。`get()` 方法像一个查询一样搜索每个注册模块中的实例。您可以将任何提供者的令牌传递给它。或者，在严格上下文检查的情况下，传递一个包含 `strict: true` 属性的选项对象。使用该选项，您需要在特定的模块中导航以获取特定的实例。\n\n```typescript\n@@filename()\nconst tasksService = app.select(TasksModule).get(TasksService, { strict: true });\n```\n\n以下是从 standalone 应用程序对象中获取实例引用方法的总结。\n\n<table>\n  <tr>\n    <td>\n      <code>get()</code>\n    </td>\n    <td>\n      Retrieves an instance of a controller or provider (including guards, filters, and so on) available in the application context.\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <code>select()</code>\n    </td>\n    <td>\n      Navigates through the module's graph to pull out a specific instance of the selected module (used together with strict mode as described above).\n    </td>\n  </tr>\n</table>\n\n> info **Hint** 在非严格模式下，root 模块默认被选择。在选择其他模块时，您需要手动导航模块图。\n\n请注意，standalone 应用程序没有网络监听器，因此与 HTTP 相关的 Nest 功能（例如中间件、拦截器、管道、守卫等）在这个上下文中不可用。\n\n例如，即使您在应用程序中注册了一个全局拦截器，然后使用 `app.get()` 方法获取控制器的实例，拦截器将不会被执行。\n\n#### 从动态模块中获取提供者\n\n在处理 [dynamic modules](/fundamentals/dynamic-modules) 时，我们需要向 `app.select` 传递相同的对象，该对象表示应用程序中注册的动态模块。例如：\n\n```typescript\n@@filename()\nexport const dynamicConfigModule = ConfigModule.register({ folder: './config' });\n\n@Module({\n  imports: [dynamicConfigModule],\n})\nexport class AppModule {}\n```\n\n然后，您可以在后续选择该模块：\n\n```typescript\n@@filename()\nconst configService = app.select(dynamicConfigModule).get(ConfigService, { strict: true });\n```\n\n#### 终止阶段\n\n如果您想在 Node 应用程序关闭后（例如在 CRON 工作中）结束脚本，必须在 `bootstrap` 函数的末尾调用 `app.close()` 方法，如下所示：\n\n```typescript\n@@filename()\nasync function bootstrap() {\n  const app = await NestFactory.createApplicationContext(AppModule);\n  // application logic...\n  await app.close();\n}\nbootstrap();\n```\n\n正如在 [Lifecycle events](/fundamentals/lifecycle-events) 章节中所述，这将触发生命周期钩子。\n\n#### 示例\n\n有一个可工作的示例可在 [here](https://github.com/nestjs/nest/tree/master/sample/18-context) 中找到。"
    ]
  ],
  "lastUpdated": "2026-02-24T02:35:44.038Z"
}