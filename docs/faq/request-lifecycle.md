<!-- 此文件从 content/faq/request-lifecycle.md 自动生成，请勿直接修改此文件 -->
<!-- 生成时间: 2026-02-25T04:12:09.600Z -->
<!-- 源文件: content/faq/request-lifecycle.md -->

### 请求生命周期

Nest 应用程序处理请求和生成响应的顺序称为 **请求生命周期**。使用中间件、管道、守卫和拦截器可以使得跟踪特定代码在请求生命周期中的执行变得困难，尤其是在全局、控制器级别和路由级别组件出现时。在一般情况下，请求将通过中间件到守卫，然后到拦截器，然后回到拦截器（在响应生成时）。

#### 中间件

中间件执行顺序特定。首先，Nest 运行全局绑定的中间件（例如 __INLINE_CODE_2__），然后运行 __LINK_15__，这些中间件根据路径确定。中间件顺序执行，类似于 Express 中间件的顺序执行。对于绑定在不同模块中的中间件，root 模块的中间件将首先执行，然后是按照 imports 数组中模块的顺序执行。

#### 守卫

守卫执行顺序是从全局守卫开始，然后是控制器守卫，最后是路由守卫。与中间件类似，守卫顺序执行。例如：

```bash
$ npm run build
```

__INLINE_CODE_3__ 将在 `nest` 之前执行， `nest` 之前执行。

> info **提示** 当讨论全局绑定的守卫 versus 控制器或路由绑定的守卫时，区别在于守卫的绑定位置。如果使用 `package.json` 或将组件提供给模块，则是全局绑定的。如果是装饰器在控制器类之前出现，则是控制器绑定的；如果是装饰器在路由声明之前出现，则是路由绑定的。

#### 拦截器

拦截器大多数遵循守卫的同一模式，唯一的区别是拦截器返回 __LINK_16__，然后 observables 将以先进后出顺序解决。因此，对于 inbound 请求，标准的全局、控制器、路由级别解决将被遵循，但是在 controller 方法处理程序返回后，响应侧将在路由、控制器、全局顺序中解决。拦截器中还可以读取由管道、控制器、服务抛出的错误。

#### 管道

管道遵循标准的全局到控制器到路由绑定顺序，同样是先进先出顺序。然而，在路由参数级别，如果您有多个管道运行，它们将在最后一个参数的管道到第一个参数的管道顺序中执行。例如，如果我们有以下控制器：

```bash
$ npm run start
```

那么 `nest start` 将在 `package.json` 之前执行， `nest new` 之前执行， `nest build` 之前执行，然后是 `tsc` 对象。 如果存在参数特定的管道，它们将在控制器和路由级别管道执行后执行。

#### 过滤器

过滤器是唯一不先解决全局的组件。相反，过滤器从最低级别开始解决，意味着执行从路由绑定的过滤器开始，然后是控制器级别，最后是全局过滤器。请注意，异常不能从过滤器到过滤器传递；如果路由级别过滤器捕获异常，控制器或全局过滤器不能捕获同一个异常。唯一能实现这种效果的方法是使用过滤器的继承。

> info **提示** 过滤器仅在请求过程中遇到未捕获异常时执行。捕获的异常，例如使用 `swc`，将不会触发 Exception Filters。一旦遇到未捕获的异常，请求将直接跳到过滤器。

#### 总结

在一般情况下，请求生命周期看起来如下：

1. incoming 请求
2. 中间件
   - 2.1. 全局绑定的中间件
   - 2.2. 模块绑定的中间件
3. 守卫
   - 3.1. 全局守卫
   - 3.2. 控制器守卫
   - 3.3. 路由守卫
4. 拦截器（pre-controller）
   - 4.1. 全局拦截器
   - 4.2. 控制器拦截器
   - 4.3. 路由拦截器
5. 管道
   - 5.1. 全局管道
   - 5.2. 控制器管道
   - 5.3. 路由管道
   - 5.4. 路由参数管道
6. 控制器（方法处理程序）
7. 服务（如果存在）
8. 拦截器（post-request）
   - 8.1. 路由拦截器
   - 8.2. 控制器拦截器
   - 8.3. 全局拦截器
9. 异常过滤器
   - 9.1. 路由
   - 9.2. 控制器
   - 9.3. 全局
10. 服务器响应